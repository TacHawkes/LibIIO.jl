<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IIO Demo · LibIIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LibIIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>IIO Demo</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Using-LibIIO.jl-with-the-IIO-demo-devices"><span>Using LibIIO.jl with the IIO demo devices</span></a></li><li class="toplevel"><a class="tocitem" href="#The-full-example"><span>The full example</span></a></li></ul></li></ul></li><li><span class="tocitem">High-level libiio bindings</span><ul><li><a class="tocitem" href="../context/">Context</a></li><li><a class="tocitem" href="../device/">Devices</a></li><li><a class="tocitem" href="../channel/">Channel</a></li><li><a class="tocitem" href="../buffer/">Buffer</a></li></ul></li><li><span class="tocitem">Low-level libiio access (for advanced users)</span><ul><li><a class="tocitem" href="../cindex/">Overview</a></li><li><a class="tocitem" href="../cscan/">Functions for scanning available contexts</a></li><li><a class="tocitem" href="../ctoplevel/">Top-level functions</a></li><li><a class="tocitem" href="../ccontext/">Context</a></li><li><a class="tocitem" href="../cdevice/">Device</a></li><li><a class="tocitem" href="../cchannel/">Channel</a></li><li><a class="tocitem" href="../cbuffer/">Buffer</a></li><li><a class="tocitem" href="../cdebug/">Debug</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>IIO Demo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IIO Demo</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tachawkes/LibIIO.jl/blob/main/docs/src/iio_demo.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="iio_demo"><a class="docs-heading-anchor" href="#iio_demo">Setting up the libiio and the IIO demo project</a><a id="iio_demo-1"></a><a class="docs-heading-anchor-permalink" href="#iio_demo" title="Permalink"></a></h1><p>For this example you need a linux system with <a href="https://wiki.analog.com/resources/tools-software/linux-software/libiio">libiio</a> installed. Many distros have a bundled package. If you prefer to build it from source, you can follow this <a href="https://wiki.analog.com/resources/tools-software/linux-software/libiio#building_on_the_linux_host_target">build guide</a>.</p><p>If you want to setup a sandbox for testing IIO, using <a href="https://multipass.run">multipass</a> (she knows it&#39;s a multipass) is a quick way to set up an Ubuntu VM where the IIO demo project can be installed.</p><p>The IIO demo project is a small demo of the IIO framework where a 16 bit ADC and a 16 bit DAC is simulated with buffer support. With default settings there is a loopback between DAC/ADC, i.e. data you send to the DAC is piped back into the ADC.</p><p>Furthermore you need to build the <a href="https://wiki.analog.com/resources/eval/user-guides/iio_demo/no-os-setup">IIO Demo</a>. This can be done with these stepse:</p><ol><li>Clone the <code>no-os</code> git repostitory from Analog Devices:</li></ol><pre><code class="language-bash hljs">git clone --recursive https://github.com/analogdevicesinc/no-OS</code></pre><ol><li>Enter into the projects folder with </li></ol><pre><code class="language-bash hljs">cd no-OS/projects/iio_demo</code></pre><ol><li>Compile the demo project using </li></ol><pre><code class="language-bash hljs">make PLATFORM = linux</code></pre><ol><li>Execute the demo project using </li></ol><pre><code class="language-bash hljs">./build/iio_demo.out</code></pre><p>Now you can use the demo devices either on the same system or from a different system. If you use another system you need to have a network connection between these two systems.</p><h1 id="Using-LibIIO.jl-with-the-IIO-demo-devices"><a class="docs-heading-anchor" href="#Using-LibIIO.jl-with-the-IIO-demo-devices">Using LibIIO.jl with the IIO demo devices</a><a id="Using-LibIIO.jl-with-the-IIO-demo-devices-1"></a><a class="docs-heading-anchor-permalink" href="#Using-LibIIO.jl-with-the-IIO-demo-devices" title="Permalink"></a></h1><p>This example will send a sine wave signal to the DAC device using buffers and reads the signal back using the ADC device with another buffer and checks that data is identical.</p><p>Create a new Julia environment with <code>LibIIO.jl</code> installed as package. Then create a new julia file and load the package with</p><pre><code class="language-julia hljs">using LibIIO</code></pre><p>Now we try to connect with the IIO daemon using the network context. This is done the following way:</p><pre><code class="language-julia hljs">uri = &quot;ip:192.168.64.2&quot;
ctx = Context(uri)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Do not forget to change the IP address to your settings. For a local connection use <code>127.0.0.1</code>.</p></div></div><p>This should print the details of the context (attributes, devices, channels etc.) on the REPL console like this:</p><pre><code class="nohighlight hljs">IIO context created with network backend.
Backend version: 1.1 (git tag: 0000000)
Backend description string: 192.168.64.2 no-OS analog 1.1.0-g0000000 #1 Tue Nov 26 09:52:32 IST 2019 armv7l
IIO context has 3 attributes:
        no-OS: 1.1.0-g0000000
        ip,ip-addr: 192.168.64.2
        uri: ip:192.168.64.2
IIO context has 2 devices:
        iio:device0: adc_demo (buffer capable)
                2 channels found:
                        voltage0: adc_in_ch0 (input, index: 0, format: le:S16/16&gt;&gt;0)
                        1 channel-specific attributes found:
                                attr 0: adc_channel_attr value: 1111
                        voltage1: adc_in_ch1 (input, index: 1, format: le:S16/16&gt;&gt;0)
                        1 channel-specific attributes found:
                                attr 0: adc_channel_attr value: 1112
                1 device-specific attributes found:
                                attr 0: adc_global_attr value: 3333
                1 debug-specific attributes found:
                                attr 0: direct_reg_access value: 0
ERROR: checking for trigger : Invalid argument (22)
        iio:device1: dac_demo (buffer capable)
                2 channels found:
                        voltage0: dac_out_ch0 (output, index: 0, format: le:S16/16&gt;&gt;0)
                        1 channel-specific attributes found:
                                attr 0: dac_channel_attr value: 1111
                        voltage1: dac_out_ch1 (output, index: 1, format: le:S16/16&gt;&gt;0)
                        1 channel-specific attributes found:
                                attr 0: dac_channel_attr value: 1112
                1 device-specific attributes found:
                                attr 0: dac_global_attr value: 4444
                1 debug-specific attributes found:
                                attr 0: direct_reg_access value: 0
ERROR: checking for trigger : Invalid argument (22)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Do not worry about the errors. This demo is built without trigger support, therefore the error message is actually correct.</p></div></div><p>The context has two devices, called <code>adc_demo</code> and <code>dac_demo</code>. It would be also possible to address them using their IDs <code>iio:device0</code> and <code>iio:devic1</code> instead of their names. To retrieve a device handle we use the code:</p><pre><code class="language-julia hljs">dac = find_device(ctx, &quot;dac_demo&quot;)
adc = find_device(ctx, &quot;adc_demo&quot;)</code></pre><p>Now we need to get a handle to the channel of each device respectively. Note that for the DAC, the argument <code>is_output</code> of the <a href="../device/#LibIIO.find_channel"><code>find_channel</code></a> function has to be set to <code>true</code>. The demo devices each have two channels, we use only the first channel (<code>voltage0</code>). The channels are named <code>adc_in_ch0</code> and <code>dac_out_ch0</code> for this example.</p><pre><code class="language-julia hljs">dac_chn = find_channel(dac, &quot;dac_out_ch0&quot;, true)
adc_chn = find_channel(adc, &quot;adc_in_ch0&quot;)</code></pre><p>Before creating a buffer for writing/reading channels, the channels have to be enabled:</p><pre><code class="language-julia hljs">enabled!(dac_chn, true)
enabled!(adc_chn, true)</code></pre><p>In the next step a buffer for each device for 400 samples is set up.</p><pre><code class="language-julia hljs">dac_buf = Buffer(dac, 400)
adc_buf = Buffer(adc, 400)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The buffer creation can be done only once, otherwise a &quot;busy&quot;-error will be issued. The buffer object should be stored savely. If you delete the buffer (e.g. with <code>dac_buf = nothing</code>) the Julia garbage collector does not run immediately (you can explicitly run it with <code>GC.gc()</code>) and so the C-pointer and connected ressources are not freed immediately. In general <code>LibIIO.jl</code> tries to properly cleanup the C-pointers using the libiio <code>destroy</code> functions but due to the nature of the garbage collector this is not done immediately upon deleting the Julia references to the objects.</p></div></div><p>For the sake of this example, we now generate 400 samples of a sine wave with two full periods:</p><pre><code class="language-julia hljs">y = round.(Int16, 10000*sin.(2π*1/200*(1:400)))</code></pre><p>This data can now be written to the <code>dac_buffer</code> object which just copies the data into the buffer&#39;s memory but this memory is still on the host computer and not on the physical device. This transfer to the device is issued by calling the <a href="../buffer/#LibIIO.push-Tuple{Buffer}"><code>push</code></a> function on the buffer.</p><pre><code class="language-julia hljs">write(dac_buffer, y)
push(dac_buffer)</code></pre><p>For a real device the data would be physically sent to the DAC device and would be measurable as an analog signal (i.e. using an oscilloscope). In this demo the data can be immediately read back using the ADC device.</p><p>First we have to issue the physical transfer from the ADC device to the buffer memory and then read the data into a Julia variable:</p><pre><code class="language-julia hljs">refill(adc_buf)
data = read(adc_buf)</code></pre><p>The data is returned as bytes, so for our 16 bit ADC/DAC devices we will receive 800 bytes of data when sending/requestion 400 samples. The data is returned as <code>Cuchar</code>/<code>UInt8</code> and has to be reinterpreted to the device sample format:</p><pre><code class="nohighlight hljs">d2 = reinterpret(Int16, data)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general this can be way more complex depending on the device. <code>iio_info</code> or using this package you get an info string for each channel which tells you how to interpret the raw binary data from the device. In this example the ADC channel has the info <code>voltage0: adc_in_ch0 (input, index: 0, format: le:S16/16&gt;&gt;0)</code>. The <code>format</code> part tells you that this device transmit in little Endian format (the library takes care of conversion when not using the <code>raw</code> mode) and signed 16 bit samples are transfered where the full 16 bits represent one sample, so a right-shift of zero (i.e. no shift at all) is required to interpet the sample. You can get a structured information of the data format of a channel using the <a href="../channel/#LibIIO.data_format-Tuple{LibIIO.Channel}"><code>data_format</code></a> function. This function will also give you a scaling factor, i.e. for temperature sensors where the integer data has to be scale to a float value.</p></div></div><p>Now the variable <code>d2</code> contains the samples read from the ADC in the correct format. To check if this matches our original signal in <code>y</code> you can use:</p><pre><code class="language-julia hljs">if all(d2 .== y)
    @info &quot;Loopback successful&quot;
else
    @error &quot;Loopback failed&quot;
end</code></pre><h1 id="The-full-example"><a class="docs-heading-anchor" href="#The-full-example">The full example</a><a id="The-full-example-1"></a><a class="docs-heading-anchor-permalink" href="#The-full-example" title="Permalink"></a></h1><pre><code class="language-julia hljs">using LibIIO

# Adjust to your settings
uri = &quot;ip:192.168.64.2&quot;

# create context
ctx = Context(uri)

# get both device handles by their name
dac = find_device(ctx, &quot;dac_demo&quot;)
adc = find_device(ctx, &quot;adc_demo&quot;)

# get both channels (adc/dac)
dac_chn = find_channel(dac, &quot;dac_out_ch0&quot;, true)
adc_chn = find_channel(adc, &quot;adc_in_ch0&quot;)

# enable the channels
enabled!(dac_chn, true)
enabled!(adc_chn, true)

# create DAC buffer with 400 samples
dac_buf = Buffer(dac, 400)

# create the ADC buffer for reading
adc_buf = Buffer(adc, 400)

# dummy signal to feed into the DAC and read back using the ADC
y = round.(Int16, 10000*sin.(2π*1/200*(1:400)))

# write the test signal into the buffer
write(dac_buf, y)

# push the buffer to the hardware
push(dac_buf)

# Read samples from the ADC hardware into the buffer
refill(adc_buf)

# Retrieve the samples from the buffer
data = read(adc_buf)

# Reinterpret as Int16, the actual sample format
d2 = reinterpret(Int16, data)

# Verify that the read signal matches the original signal
if all(d2 .== y)
    @info &quot;Loopback successful&quot;
else
    @error &quot;Loopback failed&quot;
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../context/">Context »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 26 December 2022 11:30">Monday 26 December 2022</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
